[{"categories":["other"],"content":"朋友用了一个aText，那看着使用的舒适眼馋的不行，然后只能在Mac下使用，而且貌似还得买…然后，没了。。。\n PhraseExpress(Windows) 终于无意还是有意，发现了类似的一个替代品PhraseExpress，瞬间喜欢的不行。\n 首先，Windows下就可以使用 然后，对个人使用是免费的\n 安装的话，windows下安装东西，看不懂或者不太会那就下载下来next点到底吧… 不想去找的话可以自提 密码: 87k8 简单使用步骤可以看这儿，也可以看下文另一软件介绍，两者差不多（下面偷学这个的～）\n大概说下这个软件干嘛的:\n 简单来说，自定义的用一些词汇替换另一些东西，可以定义快捷键或者命令等等，想想自动补全…\n 在使用电脑中，我们经常会输入一些很频繁很无聊的东西，比如账号了，手机了，email，etc。还有很多具体用在哪块，自己用了就知道顺手了。\n AutoKey(Linux) windows下用上个很方便，但是考虑到更多时候要在Linux下写东西，比如我的个人博客用GitHub托管，编译用jekyll，git，markdown，环境都是部署在Linux(Ubuntu)下，所以当然要搜寻Linux下能用的了。\n幸运的是，很快找到了AutoKey，这个是开源的，来由貌似就是因为上面那个很好用，但是只能windows，然后就来了个类似的，个人初步实践两者看起来挺像。\n安装步骤\nsudo add-apt-repository ppa:cdekter/ppa sudo apt-get update sudo apt-get install autokey-gtk  使用\n简单文本替换\n  右上角，点击new，创建一个Phrase，这个名字随意，就是自己看懂就行(例如 : mysite)   右上角contents部分，就是你要在输入命令后想出现的，比如我输入自己网址   点击Abbreviation后面set，进入这个页面，旁边框里面add自己需要定义的命令，或者说简写的字符(此处谢了bb,即想在输bb后直接输出 ： http://www.nonefly.com)   点击ok，save(ctrl+s也可以，通用…)。然后随便找个地方试试直接输入bb看看效果吧，你可以选择编辑器，浏览器，甚至终端，你喜欢就好。从此输** bb == http://www.nonefly.com**(ps：为写这句可纠结了，输入个bb自动换成网址，数次才好，⊙﹏⊙b汗)\n  类似vim配置，你可以用字符制定自己需要的代码什么的，比如你可以设置输入main就会出现\n1 2 3  int main(){ return 0; }   添加当前时间\n写笔记什么的，经常需要记录当前时间作为一个保存，因此也可以设置快捷键\n  还是老地方，如上第一步，只是这次New一个Script，名字仍然随意\n  在上文本处写这样函数   其他同样，然而比如此时我指dd为快捷键\n当输入dd时，会出现如下: 2015-09-06 09:26:22 CST\n  然而大部分情况下，我们不要这种格式的，那就自己制定格式\n如下是一些常用格式及效果:\n output = system.exec_command('date +\"%Y-%m-%d\"') keyboard.send_keys(output) 输出: 2015-09-07 output = system.exec_command(\"date +%Y-%m-%d\\ %I:%M\") keyboard.send_keys(output) 输出: 2015-09-07 08:32 注意日期时间之间空格时，要加 \\ 转义，否则会出错，自己试出来的，未发现正确写法该如何 还有其他格式根据自己习惯，按照上面的格式化下输出就行  最后\n可用之处当然不只这么一点点了，就需要自己摸索了，当尝试了以后，相信一定会喜欢它的。\n","description":"","tags":null,"title":"不要阻挡我偷懒，你肯定喜欢的软件","uri":"/posts/autokey/"},{"categories":["java","data structure"],"content":"注解的初识在自动生成重写诸如equals()等方法时头顶的那个@Override，还有消除那黄黄的警告线时的@SuppressWarnings，当时只是感觉可有可无的东西，对它就像只是看待一个不知道哪儿定义的一个方法而已。\n之后感觉它的神奇就是在项目使用框架时了。学习框架时用的xml配置，已经感觉挺有创意了，并没有学习annotation，在一次实际项目开发中，hibernate，spring，springMVC通通注解。那简洁的xml配置和一行代码顶数句的注解更是感到神气的不行(xml与注解各有好处，非是误导注解一定强于xml)，然后才对注解刮目相看，准备多学习一些。\n 个人信息\n注解出生时间在jdk 1.5版本。地位呢，他是一个类型，地位同于class(类)，interface(接口)，当然还有一个平级但是和它一样不是非常常见的类型:enmu(枚举)。\n项目经历\nHibernate中，用注解可以实现字段与数据库列的映射。\nSpring中注解更是用着舒服，无论是Io还是AOP的配置，使用注解效率比起xml配置都是快捷很多。而且也是在框架学习时较多的使用注解，发现注解的强大。也由此觉得再使用的基础上应该有一些进一步的了解。\n其他框架中如Junit 4版本开始后也是注解@Test代替了命名规则，数不胜数，相信在之后开发中，注解会被越来多的使用。\n技能分类\n注解有三种类型\n 自定义注解:顾名思义，就是自己写的注解了，具体的实现在之后说明。 内置注解: 也就是jdk中自己定义的注解，如之前所说@Override等都是。 元注解: 可以注解在注解上的注解(看起来有点绕口，不错~)  1 2 3 4 5 6 7  package java.lang; import java.lang.annotation.*; @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { }   如上代码，这是源码中的@Override代码，这个其实就是个自定义注解(个人想法)，只不过是jdk自己写的，所以他就是内置注解。 其中有两行\n1 2  @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE)   这儿的@Target和@Retention就是元注解。当然不止这两个。\n Documented 指示某一类型的注释将通过 javadoc 和类似的默认工具进行文档化。 Inherited 指示注释类型被自动继承。 Retention 指示注释类型的注释要保留多久。 Target 指示注释类型所适用的程序元素的种类。   具体的定义以及参数的解释在API文档或者源码【帮您找好】中java.lang.annotation包都可以很明确的了解。包括内置注解都可以直接看jdk中的具体实现。\n 实践\n在文档或jdk中元注解以及内置注解自定义都有源码参考，因此再需要了解的便是自定义注解。\n自定义注解有三个:\n 定义一个注解。在源码中和平时不一样的就是那个@interface,他于注解就相当于class于一个类，用@interface声明要定义的是一个注解，后面跟的自然是注解名称了。 应用一个注解。注解定义后，根据定义的适用范围(类，方法，字段等等)使用注解。注解不会直接影响原有代码，不管运行还是什么的 处理注解。在2中说注解不会影响代码，也许会想到不影响那怎么注入了，验证了等等。注解不会影响，但是处理注解就影响了。注解相当于给墙上打了个‘拆’字，这个不会对房子有任何损坏（别说影响美观~），但是挖掘机看见‘拆’字就会扑上去，这就不能保证房子的安然了。这儿对注解(能保留到运行期)的处理一般通过java中的反射机制来实现。   注解参数类型：\n 所有基本数据类型（int,float,boolean,byte,double,char,long,short) String、Class、enum、Annotation类型 以上所有类型的数组   举个栗子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  //1. 定义两个注解 StuId(用来说明学号) StuSex(用来定义性别)  @Target(ElementType.FIELD)//作用于字段上 @Retention(RetentionPolicy.RUNTIME)//保留到运行期 public @interface StuId{ /**此处定义成员也就是用注解时要传递的类似于参数的玩意，指定了默认值，使用时可以不写字段值 *否则必须写:如 @StuId(stuId = \"0001\") *如果是单一属性 一般声明为 String value(); *这样在使用时可以简写为 @StuId(\"0001\") */ String stuId() default \"000\";//使用时可以 @StuId 字段值会取默认值000  } @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface StuSex{ public enum sex{ 男,女; } sex stuSex() default sex.男; } //2. 使用注解(房子写个\"拆\") public class Student{ //给字段注值应该在set方法上，字段上破坏了封装性，此处无视~  @StuId(stuId = \"0001\") private String stuId; @StuSex(stuSex = sex.女) private String stuSex; //...省略getter和setter } //3. 处理注解(出动挖掘机...) public static void getStuInfo(Class\u003c?\u003e clazz){ Field[] fields = clazz.getDeclaredFields(); for(Field field :fields){ //找出其中是StuId类型的注解  if(field.isAnnotationPresent(StuId.class)){ StuId stuId = (StuId) field.getAnnotation(StuId.class); System.out.println(\"学号:\"+stuId.stuId()); } //找出其中是StuSex类型的注解  else if(field.isAnnotationPresent(StuSex.class)){ StuSex stuSex= (StuSex) field.getAnnotation(StuSex.class); System.out.println(\"性别:\"+stuSex.stuSex()); } } } //如上注解已经完成，下来测试: public class Test { public static void main(String[] args) { DellStu.getStuInfo(Student.class); } } 输出结果: 学号:0001 性别:女 //回看 2.注解使用 ，如果是这样，不写字段值  @StuId(stuId = \"0001\") private String stuId; @StuSex(stuSex = sex.女) private String stuSex; //那么输出结果(注解定义时设置的默认值): 学号:000 性别:男   个人评价\n一般情况下是用不到自己去实现一个注解的，只有开发框架什么的大牛们才会用到（为了给我这菜鸟用…），但是还是有必要简单了解一些。\n","description":"","tags":null,"title":"java中的注解（Annotation）还是要知道一些滴","uri":"/posts/aboutannotation/"},{"categories":["java","data structure"],"content":"关于斐波那契数列: 指的是这样一个数列 0, 1, 1, 2, 3, 5, 8 ... - 第0项是0，第1项是第一个1 - 从第2项开始，每一项都等于前两项之和  数学与生活关于斐波那契数列的且不谈，在程序语言学习中学习递归时，总会以此为经典示例\njava实现几种方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  /** * @author nonefly * 2015年8月27日 */ public class Gcd { /** * 解法零 * 暴力尝试 * 选一个较小的数开始尝试，直到试到2，两者都能除尽时终止 */ public static int gcd0(int a, int b) { if(a \u003c 0 || b \u003c 0) return -1; for (int i = a \u003e b ? b : a; i \u003e 1; i--) { if(a % i == 0 \u0026\u0026 b % i == 0) return i; } return 1; } /** 解法一 * 欧几里得算法（辗转相除法） * 求两个数(a b,假设a \u003e b)最大公约数, * 每次用较大数a除b取余, * 余数c不为0则让较大数等于较小数，较小数等于余数,即: * a = b; b= c; */ public static int gcd1(int a, int b) { if(a \u003c 0 || b \u003c 0) return -1; if(a == b || a == 0) return b; if(b == 0) return a; if(a \u003c b) return gcd1(a, b % a); else return gcd1(b, a % b); } /** * 解法二 * 更相减损术 来自《九章算术》 * ps:我也不知道这算法来头，只是知道算法思想，查后才知它的出处和名字~ * * ①两个数都为偶数，提出一个2 * ②一个为偶数，偶数除以二 * ③两个为奇数，大者减去小的 * ④重复以上三个步骤，直到两个数相等 */ public static int gcd2(int a, int b) { if(a \u003c 0 || b \u003c 0) return -1; if(a == b) return a; if((a \u0026 1) \u003e (b \u0026 1)) return gcd2(a, b \u003e\u003e 1); if((a \u0026 1) \u003c (b \u0026 1)) return gcd2(a \u003e\u003e 1, b); if((a \u0026 1) == 0 \u0026\u0026 (b \u0026 1) == 0) return gcd2(a \u003e\u003e 1, b \u003e\u003e 1) \u003c\u003c 1; return gcd2(Math.abs(a - b), b \u003e a ? a : b); } public static void main(String[] args) { System.out.println(gcd0(99, 66)); } }   ","description":"","tags":null,"title":"java几种方式实现斐波那契数列","uri":"/posts/javagcd/"},{"categories":["java","data structure"],"content":"equals()这个方法，在学习的时候总是用来和 == 作以区分: equals()用来比较对象的值，==用来比较地址。 如此来说当然算不上错，只是有局限性。虽然equals()方法被用来比较值，但不是它的实质。\n那equals()的实质是什么？ 是一个所有对象的一个方法…这不是废话么？好吧，equals()就是==，前提你没动她，她还是当初的她… equals()方法在Object中定义，而所有的类的都最终继承了Object，因此Object类中的equals()才是原有的面貌:\n1 2 3  public boolean equals(Object obj) { return (this == obj); }   就这样，就是用==比较的。\n那么为什么还要equals() 既然equals()就是==，那么为什么还要equals()？ 其实equals()个人觉得可以理解为对==的重写。不同于c++中可以重写操作符，java中的操作符是不能重写的，而==的比较很单纯，就是比较直接\"看到\"的东西是否一样。西红柿==番茄输出就是false，才不会管你是不是指的同一类东西。就是这么任性，不服？不服你用equals()啊。 因为我们当然不可能服了，因此我们就用equals()了，用equals()的原因就是我们可以自己定义比较规则，想让谁平等地位就能~\nequals()该怎么用 先打一段\"官腔\"，引用下API中的定义… equals 方法在非空对象引用上实现相等关系：\n  自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上equals比较中所用的信息没有被修改。 对于任何非空引用值 x，x.equals(null) 都应返回 false。   前面说了那么多equals()的坏话（当然也有拍他马屁），然后就借虎威\"为非作歹下\":\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class Equals { //运行结果测试  public static void main(String[] args) { Equals e = new Equals(); Dog dog1 = e.new Dog(\"dog\", \"black\"); Dog dog2 = e.new Dog(\"dog\", \"black\"); System.out.println(dog1.equals(dog2)); } class Dog{ String name; String clolor; public Dog() { } public Dog(String name, String clolor) { this.name = name; this.clolor = clolor; } } }    如上程序，两只狗狗即使名字颜色这仅有的属性都已经完全一样，结果仍然是false。因为equale()未重写就用之前列出的Object中的方式，等同于输出dog1==dog2,而==的比较原则就是只有同一只才是相等，长的再像也没用。 按照正常想法应该是如果颜色名字都一样了，便可以认为两只狗相等了，那么就重写equals()  1 2 3 4 5 6 7 8 9 10 11 12 13  @Override public boolean equals(Object obj) { if(this == obj) return true;//自己和自己比当然相等了  if(obj instanceof Dog){//当然要比的也得是狗狗了  Dog d = (Dog)obj; //名字、颜色一样就认为一样了  return this.name.equals(d.name) \u0026\u0026 this.clolor.equals(d.clolor); } return false; }    神经大条一点，只要是狗就是一样的  1 2 3 4  @Override public boolean equals(Object obj) { return obj instanceof Dog; }    喝了点酒，看什么都是一样的  1 2 3 4  @Override public boolean equals(Object obj) { return true; }   equals()与hashCode() 一般重写equals()都会建议按规则重写hashCode()方法，然而并不像说hashCode()规则.虽然API也建议重写了，但想说的是，并非必须这样. hashCode()重写的目的最重要的在于使用集合框架时会用到，重写会提高效率，此处不详细描述.如果自定义类作为map的key，那么hashCode()就得重写了.一般情况下并没有必要.\n总之   基本对象类型（byte,short,int,long,float,double,boolean,char）直接用==比较，这是毫无疑问的，因为他们的变量存的就是值。\n   对象类型也可以用==比较，此时比较的是这个引用存的地址（注:此地址是内存地址，不同于hash值），就是那么一串应该是十六进制的数字，他不会管这地址代表谁，只看值。因此也就是说只有是同一个对象才是true。\n    而对象比较用equals()比较，代表两个对象类似，至于具体长得像到什么程度，根据自己定义。因为一般定义两个对象里面成员一样就一样，所以片面认为equals()比较直，==比较地址了。要是不重写equals()，equals()也是比较地址好吧。或者说==也就是比较值啊，他就比较引用存的那个地址的值，只是没用解析这个地址代表什么而已。\n equals()和hashCode()的确关系很好，但并不代表必须形影不离。  关于==运算符，也可以看看之前的理解，用以区别。\n","description":"","tags":null,"title":"再多一点理解java中的equals()","uri":"/posts/moreaboutequals/"},{"categories":["java","ajax"],"content":"关于Ajax 全称（Asynchronous JavaScript and XML/异步的JavaScript和XML），这不是什么新的编程语言或或技术，而是对于多种技术的综合应用。\n要之何用？ 如果用过早期的浏览器就该有过一种‘忧伤’：注册一个账户，姓名年龄昵称密码等等填完了，点击注册，用户名已存在，瞬间泪奔。\n当然，这只戳中一个泪点。那这与Ajax有什么关系？之前的情况是因为提交信息是整个页面提交， 所以所有信息完整后才会去注册，顺便刷新下页面~。难道就不能写了名字就去查询有没有被用吗？当然可以。Ajax，可以在不用提交整个页面的情况下访问服务器。\n可以看出，Ajax作用就是在不影响正在浏览页面的情况下‘独自’去向服务端发送请求、获得数据。\n这是什么？ 那到底Ajax是什么？怎么做到的？那就要推出一个神奇控件：手机，额，不对，是XMLHttpRequest。\n先想想一个场景：自己正在介绍自己个人信息，然后突然忘了父母生日什么的。几十年前我们的做法是回家问了再来，现在呢？一边继续填写其他信息一边，打电话或者发短信问下家里，等回短信或电话了再填写刚才漏的。 OK，这里的手机便可以大胆理解为XMLHttpRequest，这个就是页面的电话。\n怎么使用？ 手机打电话也许简单，XMLHttpRequest呢？功能一样，用起来其实也差不多了…\n1. 首先，获得XMLHttpRequest对象\n打电话当然的有手机了，所以先创建XMLHttpRequest对象。只是注意的是为了兼容各种浏览器，XMLHttpRequest有所不同，老版本IEXMLHttpRequest叫做ActiveX\n2. 发送请求\n有手机了就该问家里需要的信息了。 open(请求方式, 请求地址, 是否异步)\n  请求方式:GET或者POST，手机还分发短信和打电话呢。这里也有两种方式，也就是HTTP协议中两种请求方式。 请求地址：手机获得消息需要手机号吗，XMLHttpRequest也要服务器地址了。 是否异步：true或false即发短信时候傻傻等着(false)回复呢，还是同时做后面的事(true)~   这里值得注意的是POST请求时需要设置请求头setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"); 而GET则不必须\n3. 设置回应\n接受回应主要分两点：\n 根据回应不同状态判断什么时候成功？ 成功接受回应后怎么处理？  4. 请求数据\n电话通了或者短信过去得告诉想知道什么吧？所以发送时候还得传递参数send(null); POST参数通过send();传递，而GET则在URL后以键值对形式传递，多个参数用\u0026\u0026分隔。 以上是页面使用Ajax步骤，对应一个简单使用如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  window.onload=function(){AjaxRequest();}//加载页面时调用Ajax，也可以以任意需要的方式，比如输入框按键后onKeyUp,失去焦点等等  var xmlHttp; //获得xmlHttp对象  function createXMLHttpRequest() { if (window.ActiveXObject) {//老版本IE  xmlHttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); } else if (window.XMLHttpRequest) {//其他浏览器  xmlHttp = new XMLHttpRequest(); } } //Ajax请求  function AjaxRequest() { //1. 获得xmlHttp对象（买手机）  createXMLHttpRequest(); //添加时间戳防止缓存，也可以加随机数等  var url = \" 服务器地址?timeStamp=\" + new Date().getTime(); //2. 发送请求（电话？短信？）  xmlHttp.open(\"POST\", url, true); //3. 设置回应（回掉函数）  xmlHttp.onreadystatechange = stateChange; //2.设置请求头（POST方式必须）  xmlHttp.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); //4. 请求数据（POST传参方式）  xmlHttp.send(null); } //Ajax请求信息正确返回  function stateChange() { //4-1. 根据回应不同状态判断什么时候成功？  if (xmlHttp.readyState == 4) {//4表示响应结束  if (xmlHttp.status == 200) {//200表示正确响应  //4-2. 成功接受回应后怎么处理？  parseResults(); } } } //解析数据  function parseResults() { //获得返回数据  var backData = xmlHttp.responseText; //具体处理  ... }   服务端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class DeptsServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doPost(request, response); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html;charset=utf-8\"); PrintWriter out = response.getWriter(); String s = 需要返回的信息; out.println(s); out.flush(); out.close(); } }   回顾 Asynchronous JavaScript and XML JavaScript在页面用了，那XML呢？和这个有什么关系？没有XML也是Ajax？\n狭义理解不算.但现在Ajax的定义主要指不刷新页面异步发送请求，因此没用XML也是Ajax。那不XML用什么？ XML主要来返回数据，而上述返回直接字符串，即文本。而一般常用传递方式有三种，根据不同需求选择不同方式\n     文本 XML JSON     描述能力 弱 强 较强   数据量 小 大 小   复杂度 小 大 小   扩展性 弱 强 强   验证数据 不能 能 不能   安全性 安全 安全 不安全   处理转义字符 不能 能 不能     Ajax的使用现在几乎已无处不在，也体现了他的重要。具体使用中很多的框架都可以让我们很好的使用它，比如jQuery，功能强大， 体积灵巧。具体的使用不同的集成有各自的语法，但最基本的概念流程都是一样的。\n ","description":"","tags":null,"title":"理解Ajax","uri":"/posts/aboutajax/"},{"categories":["java","points"],"content":"1. 三目运算符右结合  true?false:true == true?false:true;这个表达式等于true?false:（true == （true?false:true））; =\u003e true?false:(true == false); =\u003e true?false:false;最终应该得到false。\n 2. \u0026，|，~ 为位运算符，也是Boolean类型的逻辑运算符  此时与\u0026\u0026，|| 区别：\u0026\u0026或|| 做了优化，\u0026\u0026 前为false或者 || 前为true，则不继续运算，而\u0026 | 则做完。\n 3. final,finally,finalize  finally 异常处理补充，总会执行的代码（无论是否异常），try中return时，会在return前执行 finalize\n方法名,Object中定义，释放资源。 final修饰符   final成员\n成员初始化后值不能再改变。 final方法 方法可被继承但不可重写。编译时将主体插入而不是调用。 final类 类不可被继承  4. 传值OR传引用？  都是传一个副本（拷贝），都是传值 基本类型或者引用类型，都会传一个拷贝，基本类型传的是另一个一样值的变量，因此传参数过去后改变不会影响。\n  **引用类型事实上传的也是另一个一样值的引用，改变传的值也不会影响。**这句可能会不被赞同，如下代码（Pig是一个简单的包含一个name成员的类，便不列出代码)，将pig这个引用传入后，为pig重新引用一个类（名pig1），输出pig的name属性：\n 1 2 3 4 5 6 7 8 9 10  public class Test { public static void main(String[] args) { Pig pig = new Pig(\"pig\"); changeName(pig); System.out.println(pig.getName());//\"pig\"而不是\"pig1\"  } static void changeName(Pig pig){ pig = new Pig(\"pig1\"); } }    那如果要改值呢？传递的pig虽是另一个pig，但是他的值（即对象堆中的地址两个一样的，因此可以通过传入的pig这个引用操作传入之前指向的对象），如下代码便可以改变name\n 1 2 3  static void changeName(Pig pig){ pig.setName(\"pig1\"); //main()方法则输出\"pig1\" }   因此可以说都是传值，所谓传递引用，只是传递的引用的值可以被用来操作对应的对象\n","description":"","tags":null,"title":"java散点","uri":"/posts/javapoints/"},{"categories":["life"],"content":"  自己也只能作那所谓的的网络孝子,电话孝子了 而您们继续着自己父母身边不孝子.      您们的辛苦在别人的嘴里 您们的委屈却只能在自己心里 或许也在零星人的眼里.      再苦再累从未有过丝丝怪罪 而从未有过的理解却是让您们一次次含着泪   ![fm.jpg][1]\n[1]: {{ site.url }}/assets/images/fm.jpg\n","description":"","tags":null,"title":"母亲节快乐","uri":"/posts/mathersday/"},{"categories":["java","data structure"],"content":"这是线性表的链式实现（实现了一个双向链表），当然也可以用[顺序实现][1]，根据不同需求。两者区别如下:\n     顺序表 链表     空间性能 存储空间静态分布，通过固定长度数组保存，部分空间浪费 存储空间动态分布,不会浪费空间，但会多占用一些空间保存前/后节点信息   时间性能 逻辑顺序和存储（物理）顺序一致，因此可以通过数组下标达到随机存取目的，查找时间复杂度为O(1),但是删除和插入元素时比较麻烦，因为会牵扯到数据的移动等等问题 采用链表存储数据，插入删除时间性能很好，但是查询时需遍历链表    MyList为自定义的一个线性表接口，说明了一些线性表应该具有的功能. 下面实现了MyList接口中的方法,代码可以查看[这里][2] 事实上，在这里用接口只是为了方便提醒自己不要漏掉某些重要功能，在表的实现中，不实现MyList接口也可以正确运行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183  package com.nonefly.list; /** * 链式线性表（双向链表） * @author nonefly * @param \u003cT\u003e * 2015-5-1 */ public class MyLinkList\u003cT\u003e implements MyList\u003cT\u003e { // LinkedList\u003cE\u003e  private Node header; private Node tail; private int size = 0; public MyLinkList() { header = null; tail = null; } public int length() { return size; } public T get(int index) { if (index \u003c 0 || index \u003e size - 1) throw new IndexOutOfBoundsException(\"index\"); return getNodeByIndex(index).data; } private Node getNodeByIndex(int index) { // 根据index位置 选择从头/尾遍历 提高效率size \u003e\u003e 1 等于 size/2  if (index \u003c (size \u003e\u003e 1)) {// 从头遍历  Node node = header; for (int i = 0; i \u003c index; i++) node = node.next; return node; } else {// 后半部分，从尾遍历  Node node = tail; for (int i = size - 1; i \u003e index; i--) node = node.prev; return node; } } public int indexOf(T element) { // 这样写看起来代码简单，实则运算复杂度提高，因为每次循环if中会有大量比较判断  /* * for (Node node = header; node != null; node = node.next) { if * ((node.data == null \u0026\u0026 element == null)//element为空时 || (element != * null \u0026\u0026 element.equals(node.data)))//element不为空时 return index; * index++; } return -1; */ int index = 0; // 所以还是分开写（也是源码中写法）  if (element == null) { for (Node node = header; node != null; node = node.next) { if (node.data == null) return index; index++; } } else { for (Node node = header; node != null; node = node.next) { if (element.equals(node.data)) return index; index++; } } return -1; } //指定位置插入  public void insert(int index, T element) { if (index \u003c 0 || index \u003e size) throw new IndexOutOfBoundsException(\"index\"); if(header == null) add(element); else addBefore(element, getNodeByIndex(index)); } //在节点前添加元素  private void addBefore(T element, Node n) { final Node pre = n.prev; final Node newNode = new Node(pre, element, n);//新节点  if (pre == null)// 无前节点  header = newNode; else pre.next = newNode;//前节点next-\u003e新节点  n.prev = newNode;//下一节点prev-\u003e新节点  size++; } // 尾插法  public void add(T element) { final Node node = tail; final Node newNode = new Node(node, element, null); if (node == null)// 链表为空  header = newNode; else node.next = newNode; tail = newNode; size++; } /** * 头插法 * @param element */ public void addHead(T element) { final Node node = header; final Node newNode = new Node(null, element, node); if (node == null)// 链表为空  tail = newNode; else node.prev = newNode; header = newNode; size++; } public T delete(int index) { if (index \u003c 0 || index \u003e size - 1) throw new IndexOutOfBoundsException(\"index \"+index); return unlink(getNodeByIndex(index)); } //删除指定节点  private T unlink(Node del) { final T data = del.data; final Node prev = del.prev; final Node next = del.next; if(prev == null){//删除节点为头结点  header = next; }else{ prev.next = next; del.prev = null;//将删除节点前驱置为空  } if(next == null){//删除节点为尾结点  tail = prev; }else{ next.prev = prev; del.next = null;//将删除节点后继置为空  } del.data = null;//将删除节点数据置为空  size--; return data; } public T remove() { return unlink(tail); } public boolean isEmpty() { return size == 0; } public void clear() { //也许应该从头结点遍历置空所有节点？  header = null; tail = null; size = 0; } @Override public String toString() { if(size == 0) return \"[]\"; StringBuilder sb = new StringBuilder(\"[\"); for(Node node = header; node != null ; node = node.next) sb.append(node.data+\", \"); int len = sb.length(); return sb.delete(len - 2, len).append(\"]\").toString(); } // 链表节点  private class Node { T data;// 节点数据  Node next;// 下一个节点  Node prev;// 前一个节点  public Node() { } Node(Node prev, T data, Node next) { this.prev = prev; this.data = data; this.next = next; } } }   最后，完成表的实现我们可以写一个测试方法运行验证写的是否正确。\n链表的测试和顺序表的测试可以用同一个[测试代码][3]，只需list = new MyLinkList\u003cString\u003e();这样来初始化list。当然运行结果也应该和顺序表结果一样，便不重复。\n[1]: {{ site.url }}/java/data%20structure/2015/04/25/MyArrayList/ [2]: {{ site.url }}/java/data%20structure/2015/04/25/MyArrayList/ [3]: {{ site.url }}/java/data%20structure/2015/04/25/MyArrayList/\n","description":"","tags":null,"title":"链式线性表","uri":"/posts/mylinkedlist/"},{"categories":["java","data structure"],"content":"线性表的实现可以是顺序的（数组实现），也可以是非顺序（链式）的， 如下便是顺序表的实现，相当于简化版的java工具类中ArrayList。链式结构的实现（实现为一个双向链表），相当于java工具类中LinkedList,具体实现可以参考这里。\nMyList为自定义的一个线性表接口，说明了一些线性表应该具有的功能:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  package com.nonefly.list; /** * 线性表接口 * @author nonefly */ public interface MyList\u003cT\u003e { /** @return size 线性表元素个数*/ public int length(); /** * 获得索引i处元素 * @param index 线性表索引 * @return 第i处元素 */ public T get(int index); /** * 获得指定元素索引 * @param element 查询元素 * @return 索引 */ public int indexOf(T element); /** * 指定索引插入元素 * @param index 插入索引 * @param element 插入元素 */ public void insert (int index, T element ); /** * 顺序表末尾插入元素 * @param element */ public void add(T element); /** * 删除指定索引元素 * @param index 索引 * @return 删除元素 */ public T delete (int index ); /** * 删除最后一个 * @return 删除元素 */ public T remove(); /** * 判断顺序表是否为空 * @return boolean */ public boolean isEmpty(); /** * 清空顺序表 */ public void clear(); }   下面是顺序线性表的实现（通过数组来存储表中元素），它实现了MyList接口中的方法，同时添加了自己的一些方法，如:为了输出方便，重写了toString等.\n事实上，在这里用接口只是为了方便提醒自己不要漏掉某些重要功能，在练习表的实现中，不实现MyList接口也可以正确运行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  package com.nonefly.list; import java.util.Arrays; public class MyArrayList\u003cT\u003e implements MyList\u003cT\u003e{ private int size = 0; private int capacity; private Object[] elementData; public MyArrayList(int initialCapacity) { capacity = 1; while(capacity \u003c initialCapacity){ capacity \u003c\u003c= 1; } this.elementData = new Object[capacity]; } public MyArrayList(){ this(10); } public int length(){ return size; } @SuppressWarnings(\"unchecked\") public T get(int index) { checkIndex(index, size - 1); return (T) elementData[index]; } public int indexOf(T element) { if(element == null){ for (int i = 0; i \u003c size; i++) if (elementData[i]==null) return i; }else{ for (int i = 0; i \u003c size; i++) if (element.equals(elementData[i])) return i; } return -1; } public void insert (int index, T element ){ checkIndex(index, size); ensureCapacity(size + 1); System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } public void add(T element) { insert(size, element); } private void ensureCapacity(int minCapacity) { if(capacity \u003c minCapacity){ while(capacity \u003c minCapacity){ capacity \u003c\u003c= 1; } elementData = Arrays.copyOf(elementData, capacity); } } @SuppressWarnings(\"unchecked\") public T delete (int index ){ checkIndex(index, size - 1); T oldValue = (T) elementData[index]; int numMoved = size - index -1; if(numMoved \u003e 0) System.arraycopy(elementData, index + 1, elementData, index, numMoved); elementData[--size] = null; return oldValue; } public T remove(){ return delete(size - 1); } public boolean isEmpty(){ return size == 0; } public void clear(){ Arrays.fill(elementData, null); size = 0; } @Override public String toString() { if(size == 0) return \"[]\"; StringBuilder sb = new StringBuilder(\"[\"); for(int i = 0; i \u003c size; i++) sb.append(elementData[i]+\", \"); int len = sb.length(); return sb.delete(len - 2, len).append(\"]\").toString(); } private void checkIndex(int index, int max) { if(index \u003e max || index \u003c 0 ) throw new IndexOutOfBoundsException(\"index\"+index); } }   最后，完成表的实现我们可以写一个测试方法运行验证写的是否正确。下面的是一个简单的测试，没有对所有方面验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package com.nonefly.list; /** * 线性表测试 * @author nonefly */ public class Test { public static void main(String[] args) { MyList\u003cString\u003e list = null; list = new MyArrayList\u003cString\u003e();//顺序表测试  //list = new MyLinkList\u003cString\u003e();//链表测试  //增  list.add(\"hello\"); list.add(\"world\"); list.add(\"nonefly\"); //改  list.insert(2, null);//注意验证元素null存取  list.insert(3, \"I am\"); System.out.println(list); //删  list.delete(1); System.out.println(list); //查询  System.out.println(\"表长度为：\"+list.length());//长度  System.out.println(\"null元素所在索引：\"+list.indexOf(null));//输出1  System.out.println(\"'world'元素所在索引：\"+list.indexOf(\"world\"));//已删除，输出-1，表示错误  } }   测试结果如下：![运行结果][2]\n[2]: {{ site.url }}/assets/images/2015/arraylist.png\n","description":"","tags":null,"title":"顺序线性表","uri":"/posts/myarraylist/"},{"categories":["java","内存"],"content":"引言 1 2 3 4 5 6 7 8 9 10  public static void main(String[] args) { String str1 = new String(\"hello\"); String str2 = \"hello\"; String str3 = new String(\"hello\"); String str4 = \"hello\"; System.out.println(str1 == str2); System.out.println(str2 == str3); System.out.println(str3 == str4); String str5;// (str5 = str?)可以用==输出true? }   先来一段java代码，如果上面变量都是int之类基本类型，也许结果显然全部相等。但是:\n 如果现在是字？ 再换为随意创建的对象呢？ 再把==换为equals()呢？  分析 也许上面代码直接copy到Eclipse下瞬间便知答案，但是为什么？\n首先定义了两组变量（str1，str2与str3，str4），方式一模一样，然后用==计算互相之间差异。 那么我们就要知道==在java中比较的是地址。好吧，貌似知道了也不能直接解题。似乎还必须了解它们存放地址在哪，这样才知道是否地址相等。那便一个一个分析变量存储内存（java内存介绍便不啰嗦了，可以看这儿）。\n1  String str1 = new String(\"hello\");   这段代码执行时，用了new关键字，于是在堆中创建了String对象，保存的值便是\"hello\"(任何对象创建都是类似)。然后在堆栈（栈）中保存一个引用类型（str1）[4个字节,保存地址]。而str1存放的是\"hello\"这个对象在堆中的地址(可以想象C中指针指向一个实际值，但是java中不存在指针这一说法)。于是每new一个对象，必然在堆中新分配了空间。对于String类型这是绝对的，而且只会在堆中保存对象。但是一个类存在的静态变量，会放在静态变量区，方法体等其他仍在堆中。\n1  String str2 = \"hello\";   而执行这段代码时，str2仍然是栈中引用类型，但是java会先在常量池中寻找有没有\"hello\"这个字符串，如果有，那么str2就初始化为找到的\"hello\"的引用（不会在任何地方创建新对象）。如果没找到，会在常量池中创建，不同于new,堆中不创建对象。至此，在常量池中和堆中各有一个\"hello\"。继续:\n1 2  String str3 = new String(\"hello\"); String str4 = \"hello\";   接下来继续创建\"hello\"。str3时，又是new，想都不用想，前面str1分析中说了每次new都在堆中新创建对象。ok，现在堆中两个对象了，接着str4呢？继续在常量池创建？当然不，直接等号初始化是在常量池创建，但是前提是没有这个，而str2已经存在于常量池中，那么str4也就引用此处\"hello\"好了。至此所有创建的对象包括引用状态如下图: ![内存状态][2] 现在回到代码输出，比较地址？显然只有str2和str4引用同一个\"hello\" 地址，再其他任意两个地址都不相等。好吧，开始程序输出三个false.\n 然后根据自己想法创建一个str5，想等于str1？可以这样String str5 = str1，str3同理。如果想等于str2，或者str4呢，也可以这样？当然，而且还可以这样：\n 1  String str5 = \"hello\";//为什么？   思考 如果输出用equals()而不用==呢？\n运行程序，或者直接得出:所有的str都相等。那么么么。。。为什么O(∩_∩)O~？\n看来又要去了解[equals()的比较方式] [3]\n[2]: {{ site.url }}/assets/images/2015/20150423.png [3]: http://www.nonefly.com\n","description":"","tags":null,"title":"以==理解java内存","uri":"/posts/learnjavamemoryby/"},{"categories":["java","道德经"],"content":" 道可道 非常道 名可名 非常名 无名天地之始 有名万物之母 (故)常无欲以观其妙 常有欲以观其徼 此两者同出而异名 同谓之玄 玄之又玄 众妙之门\n 这是《道德经》第一章，【体道】。也是总章，也有人说一二章合做总章，不过无所谓，且只谈本章。 为何不加不加标点？\n 首先，作为数千年前的原经哪有标点之说？其中空格换行也只是为稍易读而加。 而且，更重要的是，加了标点意味着你已经赋予了文字以意思。如此，便离原意更远了一步。用“更”，是因为我们理解的，甚至他（老子）写的，原本便不是他想表达的。  接下来对具体的理解。\n 道，可道，非常道。名，可名，非常名。\n  第一个道，是作者想表达的一种东西，这种东西呢本是一种不可描述的，但若强行描述，说出来的就不是原有的了。 为何用这种东西代替道呢？因为这个道字，是为这种东西命名的，也不是他原来的名字。 此处道也许便是一个指针，或者引用。原本的 “道”也不知道是什么，也许是一种万物规则，或者说是宇宙还是奇点时的那个状态。“道”这个指针在堆栈中被定义了出来，而初始化的时候便指向了整个堆。被定义出来的指针，为了方便理解，还要给它命名，于是 “道”这个标志符便被用作指针名字。而事实上的 “道”不过堆内存地址中放着的还不知道的东西。 同样理解。“师者，传道授业解惑”，好吧又是“道”。老师教我们学习，也是想表达一种理解，于是用语言去描述，用各种名词案例什么的去表达。貌似和“老子”一个经历？由此，当老师把知识强行说明的时候，其实已经变了，而我们需要做的又是根据已表达的去反推究竟。这也是为何会出现只可意会，不可言传。   无，名天地之始。有，名万物之母。\n 这句话个人习惯这样断句读。这里又定义了两个变量，当然也有可能是常量，一个有 ，一个无。想用这两个分别表示天地之始与万物之母。好吧，分配空间。从哪？堆里。哦哦，原来天地之始或者万物之母都在“道”中？\n (故)常无，欲以观其妙，常有，欲以观其徼。\n 这个“故”字书上有，但看一些古书照的图片上没这个字，查得其作用为语气顺而已。 怎么又出来两个东西：常无与常有，又是新定义的？等等，这种命名规则有点熟。哦，第一句有常道，常名。上一句又已有了无和有。看来这个 常道/常名和无/有对应关系应该是无可无，非常无。有可有，非常有喽？\n回到万物之母，java所有类父类Object 好像有点像万物之母。又感觉不太对，到底“父”还是“母”？好吧，其实从它（ Object ）而来的所有类都是之母。因为new一个就有一物了。难道“常有”是“类”？ 类中定义了成员以及各种相关本领（方法）。欲以观其徼意思是想从中得到技巧，看其中端倪。刚好，在类中也可以这样做。\n再说天地之始，即“无”。那“常无”用来干嘛？欲以观其妙，好吧，又不想看具体的了，只需知道其中奥妙就行。接口（interface）如何？定义各种奥妙（方法） 但是没有具体功能。想用？可以，无中生有，常有实现（implments）了常无就行。突然感觉抽象类被设计出来特别不和谐。\n 此两者同，出而异名，同谓之玄 。玄之又玄 ，众妙之门。\n  此两者同出，而异名……\n 这里的第一句断句又有些差异，意思上着重点感觉不一样 前者强调二者本一样，后来名字才有了变化。后者强调二者来源于同处只有名字不一样。这两者原本都是玄，或者说两者都出于玄。而后玄是众妙之门，妙前文已有定义：常无，欲以观其妙。已有常无，那常有呢？再之前，有,名万物之母，万物，称之为“众”不为过吧。原来 众妙之门是有无之门？ 如此说来，类和接口也一样了？其实这么说也无不可。类可以继承，为了后代拥有祖辈能力，而接口实现，同代中学习他人能力强大自己罢了。一个纵向，一个横向，貌似不同，不过都是为了扩展罢了。 此处一生二，不由想到《周易》中 思想一元生两仪。元字，查看古籍，“玄”竟然与“元”常被互替〔详解可见南怀瑾《老子他说》第一章〕！ 这里两仪一般理解为阴阳，阴阳在古代指对立又相连现象。有无之对立不用说，相连更是如此，因为同出异名罢了，那有无也便是阴阳。由此可说：玄生有无。而玄之又玄实则一直描述“道”，则可理解道生阴阳，道生有无。 《易·系传》说：“形而上者谓之道，形而下者谓之器。 此处上下属阴阳，那道与器也是同出道而异名？这岂不矛盾？当然不，《java与模式》第一章中引用了这句话，此处道被理解为一种模式，一种思想，而器是一种技巧。怎么这种解释又似曾相识？ 常无，欲以观其妙，常有，欲以观其徼。原来此处道是我们现在说的无，器指有。一直类比的java，它在此一直为类与接口之道，但作为高级语言，与那些低级语言形成有无关系组成编译语言的道。又如二叉树中自己虽是两个子树的根节点，但又何尝不是另一棵树的孩子借点。\n道可道，非常道 说出来的道已不是真正的道。老子的理解原本已经偏离道的本意，通过自己理解更是与老子交给我们的大不相同，毕竟，老子不会java O(∩_∩)O~，可是这又有什么关系，同与异，难道不也是同出而异名？\n","description":"","tags":null,"title":"java与《道德经》总章己悟","uri":"/posts/thingkingdaodejingofjava/"},{"categories":["Life","Thought"],"content":" 追梦  懵懂  总是这样，\n匆匆瞥过，\n那身影一刻不在视线内便莫名的心慌，\n一举一动牵着心神却是不敢正眼去看。\n偶尔视线交汇，\n心跳过，\n眼离去，\n思绪迷离，\n便在书角藏一个你。\n     甜蜜  谎言里偷出点点滴滴，\n欣喜又一次能够相遇。\n是雨，\n一把伞相挤一起。\n是别离，\n书包里又一崭新递去，\n呆笑无言接过。\n     唯梦  梦回梦之地，\n予与重聚离。\n时时复出如一幕，\n醒，\n仍再难睡。\n     致亲    突然的思绪， 只是想念。\n当所有即将好许，\n却离去。\n只余回忆，\n曾说起有了共同的话语，\n您已情不自喜，\n我却未曾珍惜。\n也许只是一时兴起，\n但，\n涩在眼里，\n念在心里，\n真的想你。\n  ","description":"","tags":null,"title":"微情书","uri":"/posts/mylittlelove/"},{"categories":["java","编译原理","词法分析"],"content":"一、 实验目的 1. 通过实验对编译系统的基本理论、编译程序的基本结构有更为深入的理解和掌握； 2. 掌握编译程序设计的基本方法和步骤； 3. 能够设计实现编译系统的重要环节词法分析，同时增强编写和调试程序的能力。  二、 实验要求  单词的分类。   可将所有标识符归为一类；将常数归为另一类；保留字和分隔符则采取一词一类。\n 符号表的建立。   可事先建立一保留字表，以备在识别保留字时进行查询。变量名表及常数表则在词法分析过程中建立。\n 单词串的输出形式。   所输出的每一单词，均按形如（CLASS,VALUE）的二元式编码。\n4.数据获取及存储。 本设计中默认./src/output.txt读取源文件，运算结果存储./src/output.txt文件中\n 三、 单词分类表  注：具体及详细编码以com.nonefly.test.KeyTypes类中定义为准\n 1. 关键字表  关键字，java中共50个关键字，如下，对其按顺序一字一编码 “abstract”, “boolean”, “break”, “byte”,“case”, “catch”, “char”, “class”, “continue”, “default”, “do”,“double”, “else”, “extends”, “final”, “finally”, “float”, “for”,“if”, “implements”, “import”, “instanceof”, “int”, “interface”, “long”, “native”, “new”, “package”, “private”, “protected”, “public”, “return”, “short”, “static”, “super”, “switch”,“synchronized”, “this”, “throw”,“throws”, “transient”, “try”,“void”,“volatile”,“while”,“strictfp”,“enum”,“goto”,“const”,“assert”\n    助记符 种别编码 关键字     ABSTRACT 1 abstract   BOOLEAN 2 boolean   BREAK 3 break   BYTE 4 byte   CASE 5 case   … … …   ASSERT 50 assert    2. 运算符表 运算符，设计中涉及到+ - * / \u003e = \u003c \u0026 | ~十种，对于组合运算符如++ +=等未定义，将其分开描述。     运算符 助记符 种别编码     + PLUS 51   - MIN 52   * MUL 53   / DIV 54   \u0026 AND 55   | OR 56   ~ NOT 57   \u003e GT 58   = EQ 59   \u003c LT 60    3. 分隔符表 界符（分隔符）涉及如下几种\n , ; { } ( ) [ ] _ : . \" \\未一词一符定义，统一归为 SEPARATORS（助记符）：61（单词种别）\n 4. 其他（标识符、常数、非法字符）    类型 种别编码 助记符     标识符 71 ID   常数 0 DIGIT   非法字符 -1 ERROR    四、单词状态图 ![aaa.jpg][1]\n五、 算法描述 程序中用到的函数列表:     函数名或变量 解释      TestLexer(String fileSrc) 通过路径构造词法分析器    StringBuffer buffer； 文件读入缓冲区    char ch; 字符变量，存放最新读进的源程序字符    String strToken; 字符数组，存放构成单词符号的字符串    boolean isLetter(char ch) 判断ch是否为字母    boolean isDigit(char ch) 判断是否为数字    boolean isKeyWord(String) 判断是否为关键字    boolean isOperator(char) 判断是否为运算符    boolean isSeparators(char) 判断是否为分隔符    void analyse() 分析程序（关键代码）    void getChar() 将下一字符读到ch中，搜索指示器前移一个字符    void getBC() 检查ch空白则调用getChar()至ch中进入非空白字符    void concat() 将ch连接到strToken之后    void retract() 将搜索指示器回调一个字符位置，将ch值为空白字    void writeFile(String,String) 按照二元式规则写入文件    int getType(String args) 利用反射获取种别编码     六、 程序结构 1. 整体目录结构如下,其中： a.FileUtil.java 对文件的读写等操作 b.KeyTypes.java 定义了单词种类对应的种别编码 c.TestLexer.java 是分析器类，继承KeyTypes类，对源程序词法分析\nd.TypeUtil.java 是一个简单的判断字符种类的类 e.MainTest.java 是测试主方法类，是程序入口，通过源程序路径创建TestLexer类，调用其中词法分析方法，最后结果保存在文件中\n![ddd1.png][2]\n2. 上述类中定义方法如下，方法详细功能见（算法描述）中表格 ![ddd2.png][3]\n七、 运行结果 1. 准备 在input.txt中输入源程序（我们以本程序源代码为例，此文件必须有），output.txt中为空，作为结果输出(可以不创建，运行时自动创建)如下图:  ![bbb.png][4]\n2. 运行 在文本中，按照要求，我们以（种类编码，VALUE）格式保存结果，在控制台中，为方便观察，以（助记符，VALUE）格式打印出。（运行结果如下）  ![ccc.png][5]\n八、 设计技巧及体会 这是学习编译原理时的第一次实验，回忆试验中的过程，虽然对编程语言的提升并没有太多，但是重要的是让我们了解编程语言在通往机器与之交流的一个重要环节。了解词法分析对源程序处理分类的思想。 在设计中，实现了简单的要求并加入了自己一些想法，最终程序也可以成功运行并能按要求对结果保存。当然，其中还有一些不足，其中一部分因为与大部分设计几乎一样，因此便\"简写\"。比如对分隔符种类处理，类似于操作符以及关键字处理，因此并没有一词一类，而是统一作为一类。还有对于注释的分析，因为\"//“的注释没有想到很好的处理办法让忽视代码到行尾，因此将其当做普通分隔符处理。(后续中在得到老师帮助后已解决注释问题，对于//单行注释以及/* */多行注释都可以处理) *对于注释处理测试如下\n我们用main()方法所在类代码测试，其中两种注释类型都有包括*在输出结果中，显然已经忽略注释内容（如图中标记处），即使两种即使嵌套使用也可以正确处理 ![eee.png][6]\n此次的实验收获还是很大的，除了上述，因为用java完成对java语言的分析，因此对这门编程语言在回顾熟悉的基础上又有了新的收获。而且尝试用了平时不用的方式，比如定义常量类，通过反射以字符串获取属性值，也许在使用中因不常用有所欠缺，但按所想完成功能感觉还是很好的~ 九、源程序 源代码 [【查看】][7]\n[1]: {{ site.url }}/assets/images/2015/aaa.png [2]: {{ site.url }}/assets/images/2015/ddd1.png [3]: {{ site.url }}/assets/images/2015/ddd2.png [4]: {{ site.url }}/assets/images/2015/bbb.png [5]: {{ site.url }}/assets/images/2015/ccc.png [6]: {{ site.url }}/assets/images/2015/eee.png [7]: https://github.com/nonefly/mycode\n","description":"","tags":null,"title":"java词法分析器","uri":"/posts/javalexer/"},{"categories":null,"content":"作为一个开始,我们必须符合国际惯例,因此应该这样说出来:\nhello,world! of course, hello everyone!\n","description":"","tags":null,"title":"Hello World","uri":"/posts/hello-world/"}]
